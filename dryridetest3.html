<!DOCTYPE html>
<html lang="de">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>DryRide â€” Trocken radeln</title>
  <link rel="preconnect" href="https://maps.googleapis.com">
  <style>
    :root {
      --bg: #0f1115;
      --card: #121417;
      --muted: #9aa3b2;
      --accent: #00d084;
      --danger: #ff5252;
      --glass: rgba(255,255,255,0.03);
      --radius: 12px;
      --shadow: 0 4px 16px rgba(2,6,23,0.5);
      font-family: Inter, ui-sans-serif, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
      color-scheme: dark;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    html, body { height: 100%; }
    body {
      background: linear-gradient(180deg, #0b0c0e, #0f1115);
      color: #e6eef8;
      -webkit-font-smoothing: antialiased;
      font-size: 16px;
      display: flex;
      flex-direction: column;
      padding: 12px;
    }
    .app {
      max-width: 600px;
      margin: 0 auto;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    header {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
      margin-bottom: 12px;
    }
    header h1 {
      font-size: 20px;
      font-weight: 600;
    }
    header .sub {
      color: var(--muted);
      font-size: 14px;
      text-align: center;
    }

    .tab-nav {
      display: flex;
      gap: 8px;
      background: var(--glass);
      border-radius: var(--radius);
      padding: 4px;
      position: sticky;
      top: 12px;
      z-index: 10;
    }
    .tab-nav button {
      flex: 1;
      background: transparent;
      border: none;
      color: var(--muted);
      padding: 10px;
      font-size: 14px;
      font-weight: 500;
      cursor: pointer;
      border-radius: 8px;
      transition: background 0.2s, color 0.2s;
    }
    .tab-nav button.active {
      background: var(--accent);
      color: #061012;
      font-weight: 600;
    }
    .tab-nav button:hover:not(.active) {
      background: rgba(255,255,255,0.05);
    }

    .tab-content { display: none; }
    .tab-content.active { display: block; }

    .panel {
      background: var(--card);
      border-radius: var(--radius);
      padding: 16px;
      box-shadow: var(--shadow);
    }
    .panel h2 {
      font-size: 16px;
      margin-bottom: 12px;
    }
    .form-row {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    label {
      color: var(--muted);
      font-size: 14px;
    }
    input[type="text"], input[type="time"], select {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
      padding: 12px;
      border-radius: 8px;
      font-size: 16px;
      outline: none;
      width: 100%;
      min-height: 44px;
    }
    input::placeholder {
      color: rgba(255,255,255,0.3);
    }
    .small-btn, .action-btn, .primary {
      padding: 12px;
      border-radius: 8px;
      font-size: 14px;
      cursor: pointer;
      min-height: 44px;
      text-align: center;
    }
    .small-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
    }
    .primary {
      background: linear-gradient(90deg, var(--accent), #00c37a);
      color: #061012;
      border: none;
      font-weight: 600;
      box-shadow: 0 4px 12px rgba(0,208,132,0.15);
    }
    .action-btn {
      background: transparent;
      border: 1px solid rgba(255,255,255,0.08);
      color: inherit;
    }
    .action-btn.secondary {
      border-color: rgba(255,255,255,0.04);
    }
    .toggle-enabled {
      background: rgba(0,208,132,0.15);
      color: var(--accent);
      border: 1px solid rgba(0,208,132,0.2);
    }
    .toggle-disabled {
      background: rgba(255,82,82,0.08);
      color: var(--danger);
      border: 1px solid rgba(255,82,82,0.1);
    }
    .muted {
      color: var(--muted);
      font-size: 14px;
      margin-top: 12px;
    }

    .rides-list {
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 12px;
    }
    .ride {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 12px;
      border-radius: 8px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
    }
    .ride .meta {
      font-size: 14px;
    }
    .ride .meta .sub {
      color: var(--muted);
      font-size: 12px;
    }

    #result {
      margin-top: 12px;
      padding: 12px;
      border-radius: 8px;
      background: var(--glass);
      border: 1px solid rgba(255,255,255,0.04);
      color: var(--muted);
      font-size: 14px;
    }

    @media (min-width: 600px) {
      .app {
        max-width: 800px;
      }
      header {
        flex-direction: row;
        justify-content: space-between;
        align-items: center;
      }
      .tab-nav {
        padding: 6px;
      }
      .tab-nav button {
        font-size: 16px;
      }
      .form-row {
        flex-direction: row;
        gap: 16px;
      }
      .panel {
        padding: 20px;
      }
      .panel h2 {
        font-size: 18px;
      }
    }
    @media (min-width: 900px) {
      .app {
        max-width: 1000px;
      }
    }
  </style>
</head>
<body>
  <div class="app" role="application">
    <header>
      <div>
        <h1>DryRide</h1>
        <div class="sub">Trocken & smart radeln â€” Benachrichtigungen 1 h vorher</div>
      </div>
      <button id="notifyPermissionBtn" class="small-btn">ðŸ”” Benachrichtigungen</button>
    </header>

    <div class="tab-nav">
      <button class="tab-btn active" data-tab="adhoc">Ad-hoc</button>
      <button class="tab-btn" data-tab="routes">Routen</button>
    </div>

    <div id="adhoc" class="tab-content active">
      <div class="panel" aria-live="polite">
        <h2>Ad-hoc-Berechnung</h2>
        <div class="form-row">
          <div class="field">
            <label>Hausadresse (Ziel)</label>
            <input id="homeAddress" type="text" placeholder="z. B. MusterstraÃŸe 1, 10115 Berlin" autocomplete="off">
          </div>
          <div class="field">
            <label>Von-Adresse</label>
            <input id="startAddress" type="text" placeholder="z. B. BahnhofstraÃŸe 5" autocomplete="off">
          </div>
        </div>

        <div class="form-row">
          <div class="field">
            <label>Akzeptierter Niederschlag</label>
            <select id="rainLevel">
              <option value="0">Kein Niederschlag</option>
              <option value="0.2" selected>0.2 mm/h</option>
            </select>
          </div>
          <div class="field">
            <label>Trocken-Fenster</label>
            <select id="dryWindow">
              <option value="15">15 Minuten</option>
              <option value="30" selected>30 Minuten</option>
              <option value="60">60 Minuten</option>
              <option value="120">2 Stunden</option>
              <option value="240">4 Stunden</option>
              <option value="360">6 Stunden</option>
              <option value="540">9 Stunden</option>
            </select>
          </div>
          <div class="field">
            <label>Suchzeitraum</label>
            <select id="searchWindow">
              <option value="0.5" selected>30 Minuten</option>
              <option value="2">2 Stunden</option>
              <option value="4">4 Stunden</option>
              <option value="6">6 Stunden</option>
              <option value="9">9 Stunden</option>
            </select>
          </div>
        </div>

        <div class="form-row">
          <button class="primary" onclick="calculateSafeRide()">Berechnen: Wann losfahren?</button>
          <button class="action-btn secondary" id="saveHomeBtn">Haus speichern</button>
          <button class="action-btn secondary" id="saveStartBtn">Von speichern</button>
        </div>

        <div id="result" class="muted">Ergebnis erscheint hier.</div>
      </div>
    </div>

    <div id="routes" class="tab-content">
      <div class="panel">
        <h2>Neue Route</h2>
        <div class="form-row">
          <div class="field">
            <label>Titel</label>
            <input id="rideTitle" type="text" placeholder="z. B. Arbeit">
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Startadresse</label>
            <input id="rideOrigin" type="text" placeholder="Start (Autocomplete)">
          </div>
          <div class="field">
            <label>Ziel (leer = Hausadresse)</label>
            <input id="rideDestination" type="text" placeholder="Ziel (Autocomplete)">
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Abfahrtszeit</label>
            <input id="rideTime" type="time" value="07:30">
          </div>
          <div class="field">
            <label>Wiederholung</label>
            <select id="rideRepeat">
              <option value="once">Einmalig</option>
              <option value="daily" selected>TÃ¤glich</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <div class="field">
            <label>Trocken-Fenster</label>
            <select id="rideWindow">
              <option value="15">15 Minuten</option>
              <option value="30" selected>30 Minuten</option>
              <option value="60">60 Minuten</option>
              <option value="120">2 Stunden</option>
              <option value="240">4 Stunden</option>
              <option value="360">6 Stunden</option>
              <option value="540">9 Stunden</option>
            </select>
          </div>
          <div class="field">
            <label>Max Regen (mm/h)</label>
            <select id="rideRainLevel">
              <option value="0" selected>Kein Niederschlag</option>
              <option value="0.2">0.2 mm/h</option>
            </select>
          </div>
        </div>
        <div class="form-row">
          <button class="primary" onclick="saveRide()">Route speichern</button>
          <button class="action-btn secondary" onclick="clearRideForm()">Form lÃ¶schen</button>
        </div>

        <div class="rides-list">
          <h3 style="margin: 12px 0 8px; font-size: 16px; color: #dfe9f3">Deine Routen</h3>
          <div id="ridesList" class="rides-list"></div>
        </div>
      </div>
    </div>
  </div>

  <script async
    src="https://maps.googleapis.com/maps/api/js?key=AIzaSyCfmA_2wFMG2eXCJF0stxziBnM4CVNpoB0&libraries=places,directions">
  </script>

  <script>
  const KEY_RIDES = 'dryride_rides_v1';
  const KEY_HOME = 'dryride_home_v1';
  const KEY_START = 'dryride_start_v1';
  let acHome, acStart, acRideOrigin, acRideDest;

  // Tab-Navigation
  document.querySelectorAll('.tab-btn').forEach(button => {
    button.addEventListener('click', () => {
      document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
      document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));
      button.classList.add('active');
      document.getElementById(button.dataset.tab).classList.add('active');
    });
  });

  function showResult(msg, type) {
    const el = document.getElementById('result');
    el.innerHTML = msg;
    el.className = type ? type : 'muted';
  }

  function whenMapsReady(cb) {
    if (window.google && google.maps && google.maps.places && google.maps.DirectionsService) return cb();
    setTimeout(() => whenMapsReady(cb), 200);
  }

  whenMapsReady(() => {
    acHome = new google.maps.places.Autocomplete(document.getElementById('homeAddress'));
    acStart = new google.maps.places.Autocomplete(document.getElementById('startAddress'));
    acRideOrigin = new google.maps.places.Autocomplete(document.getElementById('rideOrigin'));
    acRideDest = new google.maps.places.Autocomplete(document.getElementById('rideDestination'));
  });

  function saveHome() { localStorage.setItem(KEY_HOME, document.getElementById('homeAddress').value); showResult('Hausadresse gespeichert'); }
  function saveStart() { localStorage.setItem(KEY_START, document.getElementById('startAddress').value); showResult('Startadresse gespeichert'); }

  document.getElementById('saveHomeBtn').onclick = saveHome;
  document.getElementById('saveStartBtn').onclick = saveStart;

  function loadRides() {
    const r = localStorage.getItem(KEY_RIDES);
    const rides = r ? JSON.parse(r) : [];
    return rides.map(ride => ({
      ...ride,
      maxRain: [0, 0.2].includes(ride.maxRain) ? ride.maxRain : 0.2,
      window: [15, 30, 60, 120, 240, 360, 540].includes(ride.window) ? ride.window : 30
    }));
  }

  function saveRides(r) { localStorage.setItem(KEY_RIDES, JSON.stringify(r)); renderRides(); }

  function clearRideForm() {
    document.getElementById('rideTitle').value = '';
    document.getElementById('rideOrigin').value = '';
    document.getElementById('rideDestination').value = '';
    document.getElementById('rideTime').value = '07:30';
    document.getElementById('rideRepeat').value = 'daily';
    document.getElementById('rideWindow').value = '30';
    document.getElementById('rideRainLevel').value = '0';
  }

  function saveRide() {
    const rides = loadRides();
    const id = Date.now();
    const r = {
      id,
      title: document.getElementById('rideTitle').value || 'unnamed',
      originAddress: document.getElementById('rideOrigin').value,
      destinationAddress: document.getElementById('rideDestination').value || localStorage.getItem(KEY_HOME),
      time: document.getElementById('rideTime').value,
      repeat: document.getElementById('rideRepeat').value,
      window: parseInt(document.getElementById('rideWindow').value),
      maxRain: parseFloat(document.getElementById('rideRainLevel').value),
      enabled: true
    };
    rides.push(r);
    saveRides(rides);
    clearRideForm();
  }

  function deleteRide(id) {
    const rides = loadRides().filter(r => r.id !== id);
    saveRides(rides);
  }

  async function getWeatherForecast(lat, lng) {
    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&hourly=precipitation&forecast_days=1`;
    const res = await fetch(url);
    const data = await res.json();
    const time = data.hourly.time;
    const precipitation = data.hourly.precipitation;
    return { time, precipitation };
  }

  async function getPrecipAtTime(lat, lng, forecastTime) {
    try {
      const weather = await getWeatherForecast(lat, lng);
      let closestIdx = 0, minDiff = 1e12;
      weather.time.forEach((t, i) => {
        const diff = Math.abs(new Date(t) - forecastTime);
        if (diff < minDiff) { minDiff = diff; closestIdx = i; }
      });
      return weather.precipitation[closestIdx];
    } catch (e) {
      return null;
    }
  }

  async function updateCurrentPrecipDisplay() {
    const startEl = document.getElementById('startAddress');
    const startVal = startEl.value;
    if (!startVal) return;
    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ address: startVal }, async function(results, status) {
      if (status === 'OK' && results[0]) {
        const loc = results[0].geometry.location;
        const now = new Date();
        console.group('Aktueller Niederschlag fÃ¼r: ' + startVal);
        console.log('Koordinaten:', { lat: loc.lat(), lng: loc.lng() });
        console.log('Zeitpunkt:', now.toLocaleString('de-DE'));
        const precip = await getPrecipAtTime(loc.lat(), loc.lng(), now);
        if (precip === null) {
          showResult('Suche...', 'muted');
          console.log('Suche Wetterdaten fÃ¼r:', { lat: loc.lat(), lng: loc.lng(), time: now.toLocaleString('de-DE') });
          console.groupEnd();
          return;
        }
        const limit = parseFloat(document.getElementById('rainLevel').value);
        const dryWindow = parseInt(document.getElementById('dryWindow').value) * 60 * 1000;
        const searchWindow = parseFloat(document.getElementById('searchWindow').value) * 3600 * 1000;
        console.log('Einstellungen:', {
          Niederschlag: precip.toFixed(1) + ' mm/h',
          Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)',
          Grenzwert: limit + ' mm/h',
          TrockenFenster: (dryWindow / 60000) + ' Minuten',
          Suchzeitraum: (searchWindow / 3600) + ' Stunden'
        });

        if (dryWindow > searchWindow) {
          console.warn(`Warnung: Trocken-Fenster (${dryWindow / 60000} Minuten) ist grÃ¶ÃŸer als Suchzeitraum (${searchWindow / 3600} Stunden). Suche wird auf Suchzeitraum beschrÃ¤nkt.`);
        }

        if (precip <= limit) {
          let isDryWindow = true;
          let firstRainTime = null;
          console.group('Trocken-Fenster-PrÃ¼fung (Startpunkt)');
          for (let offset = 0; offset <= Math.min(dryWindow, searchWindow); offset += 5 * 60 * 1000) {
            const checkTime = new Date(now.getTime() + offset);
            const checkPrecip = await getPrecipAtTime(loc.lat(), loc.lng(), checkTime);
            if (checkPrecip === null) {
              showResult('Suche...', 'muted');
              console.log('Suche Wetterdaten fÃ¼r:', { lat: loc.lat(), lng: loc.lng(), time: checkTime.toLocaleString('de-DE') });
              console.groupEnd();
              console.groupEnd();
              return;
            }
            console.log(`Niederschlag bei ${checkTime.toLocaleTimeString('de-DE')}:`, {
              Niederschlag: checkPrecip.toFixed(1) + ' mm/h',
              Akzeptiert: checkPrecip <= limit ? 'Ja' : 'Nein (Regen)'
            });
            if (checkPrecip > limit) {
              isDryWindow = false;
              firstRainTime = checkTime;
              break;
            }
          }
          console.groupEnd();

          if (isDryWindow) {
            let nextRainTime = null;
            console.group('Suche nach nÃ¤chstem Regenfenster');
            for (let offset = dryWindow + 5 * 60 * 1000; offset <= searchWindow; offset += 5 * 60 * 1000) {
              const checkTime = new Date(now.getTime() + offset);
              const checkPrecip = await getPrecipAtTime(loc.lat(), loc.lng(), checkTime);
              if (checkPrecip === null) {
                showResult('Suche...', 'muted');
                console.log('Suche Wetterdaten fÃ¼r:', { lat: loc.lat(), lng: loc.lng(), time: checkTime.toLocaleString('de-DE') });
                console.groupEnd();
                console.groupEnd();
                return;
              }
              console.log(`Niederschlag bei ${checkTime.toLocaleTimeString('de-DE')}:`, {
                Niederschlag: checkPrecip.toFixed(1) + ' mm/h',
                Akzeptiert: checkPrecip <= limit ? 'Ja' : 'Nein (Regen)'
              });
              if (checkPrecip > limit) {
                nextRainTime = checkTime;
                break;
              }
            }
            console.groupEnd();

            const timeStr = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            const rainTimeStr = nextRainTime ? nextRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : 'unbekannt';
            showResult(`ðŸš² Trockenes Zeitfenster ab ${timeStr}, Regen erwartet ab ${rainTimeStr}`, 'success');
            console.log('Ergebnis:', {
              Trockenes_Zeitfenster: timeStr,
              NÃ¤chstes_Regenfenster: rainTimeStr,
              Nachricht: `Trockenes Zeitfenster ab ${timeStr}, Regen erwartet ab ${rainTimeStr}`
            });
            console.groupEnd();
            return;
          }
        }

        console.group(`Suche nach trockenem Zeitfenster (bis ${(searchWindow / 3600)} Stunden)`);
        const endTime = new Date(now.getTime() + searchWindow);
        let firstDryTime = null;
        let nextRainTime = null;
        const interval = searchWindow <= 0.5 * 3600 * 1000 ? 5 * 60 * 1000 : 3600 * 1000;
        for (let offset = interval; offset <= searchWindow; offset += interval) {
          const checkTime = new Date(now.getTime() + offset);
          console.group(`PrÃ¼fung fÃ¼r Startzeit: ${checkTime.toLocaleString('de-DE')}`);
          let isDryWindow = true;
          for (let windowOffset = 0; windowOffset <= Math.min(dryWindow, searchWindow - offset); windowOffset += 5 * 60 * 1000) {
            const windowCheckTime = new Date(checkTime.getTime() + windowOffset);
            if (windowCheckTime > endTime) {
              console.log('Zeitpunkt Ã¼berschreitet Suchzeitraum:', windowCheckTime.toLocaleString('de-DE'));
              break;
            }
            const checkPrecip = await getPrecipAtTime(loc.lat(), loc.lng(), windowCheckTime);
            if (checkPrecip === null) {
              showResult('Suche...', 'muted');
              console.log('Suche Wetterdaten fÃ¼r:', { lat: loc.lat(), lng: loc.lng(), time: windowCheckTime.toLocaleString('de-DE') });
              console.groupEnd();
              console.groupEnd();
              console.groupEnd();
              return;
            }
            console.log(`Niederschlag bei ${windowCheckTime.toLocaleTimeString('de-DE')}:`, {
              Niederschlag: checkPrecip.toFixed(1) + ' mm/h',
              Akzeptiert: checkPrecip <= limit ? 'Ja' : 'Nein (Regen)'
            });
            if (checkPrecip > limit) {
              isDryWindow = false;
              break;
            }
          }
          if (isDryWindow) {
            firstDryTime = checkTime;
            console.group('Suche nach nÃ¤chstem Regenfenster');
            for (let rainOffset = dryWindow + 5 * 60 * 1000; rainOffset <= searchWindow; rainOffset += 5 * 60 * 1000) {
              const rainCheckTime = new Date(checkTime.getTime() + rainOffset);
              if (rainCheckTime > endTime) {
                console.log('Zeitpunkt Ã¼berschreitet Suchzeitraum:', rainCheckTime.toLocaleString('de-DE'));
                break;
              }
              const checkPrecip = await getPrecipAtTime(loc.lat(), loc.lng(), rainCheckTime);
              if (checkPrecip === null) {
                showResult('Suche...', 'muted');
                console.log('Suche Wetterdaten fÃ¼r:', { lat: loc.lat(), lng: loc.lng(), time: rainCheckTime.toLocaleString('de-DE') });
                console.groupEnd();
                console.groupEnd();
                console.groupEnd();
                return;
              }
              console.log(`Niederschlag bei ${rainCheckTime.toLocaleTimeString('de-DE')}:`, {
                Niederschlag: checkPrecip.toFixed(1) + ' mm/h',
                Akzeptiert: checkPrecip <= limit ? 'Ja' : 'Nein (Regen)'
              });
              if (checkPrecip > limit) {
                nextRainTime = rainCheckTime;
                break;
              }
            }
            console.groupEnd();
            break;
          }
          console.groupEnd();
        }
        console.groupEnd();

        if (firstDryTime) {
          const timeStr = firstDryTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
          const rainTimeStr = nextRainTime ? nextRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : 'unbekannt';
          showResult(`ðŸŒ§ Aktueller Regen: ${precip.toFixed(1)} mm/h â€” trockenes Zeitfenster ab ${timeStr}, Regen erwartet ab ${rainTimeStr}`, 'muted');
          console.log('Ergebnis:', {
            Aktueller_Niederschlag: precip.toFixed(1) + ' mm/h',
            Trockenes_Zeitfenster: firstDryTime.toLocaleString('de-DE'),
            NÃ¤chstes_Regenfenster: rainTimeStr,
            Nachricht: `Aktueller Regen: ${precip.toFixed(1)} mm/h â€” trockenes Zeitfenster ab ${timeStr}, Regen erwartet ab ${rainTimeStr}`
          });
        } else {
          showResult(`ðŸŒ§ Aktueller Regen: ${precip.toFixed(1)} mm/h â€” kein trockenes Zeitfenster innerhalb der nÃ¤chsten ${(searchWindow / 3600)} Stunden`, 'muted');
          console.log('Ergebnis:', `Kein trockenes Zeitfenster innerhalb der nÃ¤chsten ${(searchWindow / 3600)} Stunden`);
        }
        console.groupEnd();
      }
    });
  }
  setInterval(updateCurrentPrecipDisplay, 60 * 1000);
  updateCurrentPrecipDisplay();

  async function renderRides() {
    const list = document.getElementById('ridesList');
    const rides = loadRides();
    list.innerHTML = rides.length ? '' : '<div class="muted">Keine Routen</div>';
    const geocoder = new google.maps.Geocoder();
    for (const r of rides) {
      const el = document.createElement('div'); el.className = 'ride';
      const left = document.createElement('div'); left.className = 'meta';
      left.innerHTML = `<strong>${r.title}</strong>
        <div class="sub">${r.originAddress} â†’ ${r.destinationAddress}</div>
        <div class="sub">${r.time} Â· ${r.repeat}</div>
        <div class="sub" id="precip_${r.id}">ðŸŒ¦ Ladenâ€¦</div>`;
      const right = document.createElement('div');
      const toggle = document.createElement('button'); toggle.className = 'action-btn ' + (r.enabled ? 'toggle-enabled' : 'toggle-disabled'); toggle.textContent = r.enabled ? 'Aktiv' : 'Inaktiv';
      toggle.onclick = () => { r.enabled = !r.enabled; saveRides(loadRides().map(x => x.id === r.id ? r : x)); renderRides(); };
      const edit = document.createElement('button'); edit.className = 'action-btn'; edit.textContent = 'Bearbeiten'; edit.onclick = () => loadRideIntoForm(r.id);
      const del = document.createElement('button'); del.className = 'action-btn secondary'; del.textContent = 'LÃ¶schen'; del.onclick = () => deleteRide(r.id);
      right.appendChild(toggle); right.appendChild(edit); right.appendChild(del);
      el.appendChild(left); el.appendChild(right); list.appendChild(el);

      geocoder.geocode({ address: r.destinationAddress }, async function(results, status) {
        if (status === 'OK' && results[0]) {
          const loc = results[0].geometry.location;
          const p = await getPrecipAtTime(loc.lat(), loc.lng(), new Date());
          const elp = document.getElementById(`precip_${r.id}`);
          if (elp) elp.innerHTML = p !== null ? `ðŸŒ¦ Aktueller Regen: ${p.toFixed(1)} mm/h` : 'ðŸŒ¦ Suche...';
        }
      });
    }
  }

  function loadRideIntoForm(id) {
    const r = loadRides().find(x => x.id === id); if (!r) return;
    document.getElementById('rideTitle').value = r.title;
    document.getElementById('rideOrigin').value = r.originAddress;
    document.getElementById('rideDestination').value = r.destinationAddress;
    document.getElementById('rideTime').value = r.time;
    document.getElementById('rideRepeat').value = r.repeat;
    document.getElementById('rideWindow').value = r.window;
    document.getElementById('rideRainLevel').value = r.maxRain;
    document.querySelector('.tab-btn[data-tab="routes"]').click();
  }

  function escapeHtml(text) { const div = document.createElement('div'); div.textContent = text; return div.innerHTML; }

  async function calculateSafeRide() {
    showResult('Berechneâ€¦');
    const startVal = document.getElementById('startAddress').value;
    const destVal = document.getElementById('homeAddress').value;
    if (!startVal || !destVal) { showResult('Bitte Start und Ziel eingeben', 'danger'); return; }
    console.group('DryRide Berechnung: ' + startVal + ' â†’ ' + destVal);

    const geocoder = new google.maps.Geocoder();
    geocoder.geocode({ address: startVal }, async function(results1, status1) {
      if (status1 !== 'OK' || !results1[0]) { 
        showResult('Startadresse nicht gefunden', 'danger'); 
        console.error('Startadresse nicht gefunden:', startVal);
        console.groupEnd();
        return; 
      }
      const loc1 = results1[0].geometry.location;
      console.log('Startadresse Koordinaten:', { lat: loc1.lat(), lng: loc1.lng() });

      geocoder.geocode({ address: destVal }, async function(results2, status2) {
        if (status2 !== 'OK' || !results2[0]) { 
          showResult('Zieladresse nicht gefunden', 'danger'); 
          console.error('Zieladresse nicht gefunden:', destVal);
          console.groupEnd();
          return; 
        }
        const loc2 = results2[0].geometry.location;
        console.log('Zieladresse Koordinaten:', { lat: loc2.lat(), lng: loc2.lng() });

        const directionsService = new google.maps.DirectionsService();
        directionsService.route({
          origin: startVal,
          destination: destVal,
          travelMode: google.maps.TravelMode.BICYCLING
        }, async (result, status) => {
          if (status !== 'OK') { 
            showResult('Route nicht gefunden', 'danger'); 
            console.error('Route nicht gefunden:', status);
            console.groupEnd();
            return; 
          }
          const duration = result.routes[0].legs[0].duration.value;
          const path = result.routes[0].overview_path;
          console.log('Route berechnet:', {
            Fahrdauer_Sekunden: duration,
            Fahrdauer_Stunden: (duration / 3600).toFixed(2),
            Anzahl_Zwischenpunkte: path.length
          });

          const now = new Date();
          const limit = parseFloat(document.getElementById('rainLevel').value);
          const dryWindow = parseInt(document.getElementById('dryWindow').value) * 60 * 1000;
          const searchWindow = parseFloat(document.getElementById('searchWindow').value) * 3600 * 1000;
          const endTime = new Date(now.getTime() + searchWindow);
          console.log('Einstellungen:', {
            rainLevel: limit + ' mm/h',
            dryWindow: (dryWindow / 60000) + ' Minuten',
            searchWindow: (searchWindow / 3600) + ' Stunden',
            Startzeit: now.toLocaleString('de-DE'),
            Endzeit: endTime.toLocaleString('de-DE')
          });

          // Konvertiere dryWindow in lesbare Einheit
          const dryWindowHours = dryWindow / (60 * 60 * 1000);
          const dryWindowStr = dryWindowHours >= 1 ? `${dryWindowHours} Stunden` : `${dryWindow / (60 * 1000)} Minuten`;

          if (dryWindow > searchWindow) {
            console.warn(`Warnung: Trocken-Fenster (${dryWindow / 60000} Minuten) ist grÃ¶ÃŸer als Suchzeitraum (${searchWindow / 3600} Stunden). Suche wird auf Suchzeitraum beschrÃ¤nkt.`);
          }

          const interval = 5 * 60;
          const numIntervals = Math.ceil(duration / interval);
          const points = [];
          console.group('5-Minuten-Abschnitte');
          for (let i = 0; i <= numIntervals; i++) {
            const progress = Math.min(i * interval / duration, 1);
            const index = Math.floor(progress * (path.length - 1));
            const point = path[index];
            const timeAtPoint = new Date(now.getTime() + progress * duration * 1000);
            points.push({ lat: point.lat(), lng: point.lng(), time: timeAtPoint });
            console.log(`Abschnitt ${i}:`, {
              Fortschritt: (progress * 100).toFixed(2) + '%',
              Koordinaten: { lat: point.lat(), lng: point.lng() },
              Zeitpunkt: timeAtPoint.toLocaleString('de-DE')
            });
          }
          console.groupEnd();

          console.group('NiederschlagsprÃ¼fung');
          let firstRainTime = null;
          let firstRainPoint = null;
          for (const point of points) {
            if (point.time > endTime) {
              console.log('Zeitpunkt Ã¼berschreitet Suchzeitraum:', point.time.toLocaleString('de-DE'));
              break;
            }
            const precip = await getPrecipAtTime(point.lat, point.lng, point.time);
            if (precip === null) { 
              showResult('Suche...', 'muted'); 
              console.log('Suche Wetterdaten fÃ¼r:', { lat: point.lat, lng: point.lng, time: point.time.toLocaleString('de-DE') });
              console.groupEnd();
              console.groupEnd();
              return; 
            }
            console.log(`Niederschlag bei ${point.time.toLocaleTimeString('de-DE')}:`, {
              Koordinaten: { lat: point.lat, lng: point.lng },
              Niederschlag: precip.toFixed(1) + ' mm/h',
              Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)'
            });
            if (precip > limit) {
              firstRainTime = point.time;
              firstRainPoint = point;
              break;
            }
          }
          console.groupEnd();

          if (!firstRainTime) {
            console.group('Suche nach nÃ¤chstem Regenfenster');
            let nextRainTime = null;
            for (let offset = duration * 1000 + 5 * 60 * 1000; offset <= searchWindow; offset += 5 * 60 * 1000) {
              const checkTime = new Date(now.getTime() + offset);
              const progress = Math.min((offset - duration * 1000) / (duration * 1000), 1);
              const index = Math.floor(progress * (path.length - 1));
              const point = path[index] || path[path.length - 1];
              const precip = await getPrecipAtTime(point.lat(), point.lng(), checkTime);
              if (precip === null) {
                showResult('Suche...', 'muted');
                console.log('Suche Wetterdaten fÃ¼r:', { lat: point.lat(), lng: point.lng(), time: checkTime.toLocaleString('de-DE') });
                console.groupEnd();
                console.groupEnd();
                return;
              }
              console.log(`Niederschlag bei ${checkTime.toLocaleTimeString('de-DE')}:`, {
                Koordinaten: { lat: point.lat(), lng: point.lng() },
                Niederschlag: precip.toFixed(1) + ' mm/h',
                Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)'
              });
              if (precip > limit) {
                nextRainTime = checkTime;
                break;
              }
            }
            console.groupEnd();

            const timeStr = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            const rainTimeStr = nextRainTime ? nextRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : 'kein Regen erwartet';
            showResult(`ðŸš² Von jetzt, ${timeStr} bis zum Ziel in ${dryWindowStr} trocken, ${rainTimeStr}`, 'success');
            console.log('Ergebnis:', {
              Trockenes_Zeitfenster: timeStr,
              NÃ¤chstes_Regenfenster: rainTimeStr,
              Nachricht: `Von jetzt, ${timeStr} bis zum Ziel in ${dryWindowStr} trocken, ${rainTimeStr}`
            });
            console.groupEnd();
            return;
          }

          console.group('Trocken-Fenster-PrÃ¼fung');
          const windowEndTime = new Date(firstRainTime.getTime() - Math.min(dryWindow, searchWindow));
          console.log('Erster Regen:', {
            Zeitpunkt: firstRainTime.toLocaleString('de-DE'),
            Koordinaten: { lat: firstRainPoint.lat, lng: firstRainPoint.lng },
            TrockenFenster_Ende: windowEndTime.toLocaleString('de-DE'),
            TrockenFenster_ErfÃ¼llt: windowEndTime > now ? 'Ja' : 'Nein'
          });
          if (windowEndTime > now) {
            console.group('Suche nach nÃ¤chstem Regenfenster');
            let nextRainTime = null;
            for (let offset = firstRainTime.getTime() - now.getTime() + 5 * 60 * 1000; offset <= searchWindow; offset += 5 * 60 * 1000) {
              const checkTime = new Date(now.getTime() + offset);
              const progress = Math.min((offset - duration * 1000) / (duration * 1000), 1);
              const index = Math.floor(progress * (path.length - 1));
              const point = path[index] || path[path.length - 1];
              const precip = await getPrecipAtTime(point.lat(), point.lng(), checkTime);
              if (precip === null) {
                showResult('Suche...', 'muted');
                console.log('Suche Wetterdaten fÃ¼r:', { lat: point.lat(), lng: point.lng(), time: checkTime.toLocaleString('de-DE') });
                console.groupEnd();
                console.groupEnd();
                console.groupEnd();
                return;
              }
              console.log(`Niederschlag bei ${checkTime.toLocaleTimeString('de-DE')}:`, {
                Koordinaten: { lat: point.lat(), lng: point.lng() },
                Niederschlag: precip.toFixed(1) + ' mm/h',
                Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)'
              });
              if (precip > limit) {
                nextRainTime = checkTime;
                break;
              }
            }
            console.groupEnd();

            const timeStr = now.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            const rainTimeStr = nextRainTime ? nextRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : 'kein Regen erwartet';
            showResult(`ðŸš² Von jetzt, ${timeStr} bis zum Ziel in ${dryWindowStr} trocken, ${rainTimeStr}`, 'success');
            console.log('Ergebnis:', {
              Trockenes_Zeitfenster: timeStr,
              NÃ¤chstes_Regenfenster: rainTimeStr,
              Nachricht: `Von jetzt, ${timeStr} bis zum Ziel in ${dryWindowStr} trocken, ${rainTimeStr}`
            });
            console.groupEnd();
            console.groupEnd();
            return;
          }
          console.groupEnd();

          console.group(`Suche nach trockenem Zeitfenster (bis ${(searchWindow / 3600)} Stunden)`);
          let firstDryTime = null;
          let nextRainTime = null;
          const searchInterval = searchWindow <= 0.5 * 3600 * 1000 ? 5 * 60 * 1000 : 3600 * 1000;
          for (let offset = searchInterval; offset <= searchWindow; offset += searchInterval) {
            const startTime = new Date(now.getTime() + offset);
            if (startTime > endTime) {
              console.log('Startzeit Ã¼berschreitet Suchzeitraum:', startTime.toLocaleString('de-DE'));
              break;
            }
            let isDry = true;
            console.group(`PrÃ¼fung fÃ¼r Startzeit: ${startTime.toLocaleString('de-DE')}`);
            for (let i = 0; i <= numIntervals; i++) {
              const progress = Math.min(i * interval / duration, 1);
              const index = Math.floor(progress * (path.length - 1));
              const point = path[index];
              const timeAtPoint = new Date(startTime.getTime() + progress * duration * 1000);
              if (timeAtPoint > endTime) {
                console.log('Zeitpunkt Ã¼berschreitet Suchzeitraum:', timeAtPoint.toLocaleString('de-DE'));
                break;
              }
              const precip = await getPrecipAtTime(point.lat, point.lng, timeAtPoint);
              if (precip === null) { 
                showResult('Suche...', 'muted'); 
                console.log('Suche Wetterdaten fÃ¼r:', { lat: point.lat, lng: point.lng, time: timeAtPoint.toLocaleString('de-DE') });
                console.groupEnd();
                console.groupEnd();
                console.groupEnd();
                return; 
              }
              console.log(`Niederschlag bei ${timeAtPoint.toLocaleTimeString('de-DE')}:`, {
                Koordinaten: { lat: point.lat, lng: point.lng },
                Niederschlag: precip.toFixed(1) + ' mm/h',
                Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)'
              });
              if (precip > limit) {
                isDry = false;
                break;
              }
            }
            if (isDry) {
              firstDryTime = startTime;
              console.group('Suche nach nÃ¤chstem Regenfenster');
              for (let rainOffset = duration * 1000 + 5 * 60 * 1000; rainOffset <= searchWindow; rainOffset += 5 * 60 * 1000) {
                const checkTime = new Date(startTime.getTime() + rainOffset);
                if (checkTime > endTime) {
                  console.log('Zeitpunkt Ã¼berschreitet Suchzeitraum:', checkTime.toLocaleString('de-DE'));
                  break;
                }
                const progress = Math.min((rainOffset - duration * 1000) / (duration * 1000), 1);
                const index = Math.floor(progress * (path.length - 1));
                const point = path[index] || path[path.length - 1];
                const precip = await getPrecipAtTime(point.lat(), point.lng(), checkTime);
                if (precip === null) {
                  showResult('Suche...', 'muted');
                  console.log('Suche Wetterdaten fÃ¼r:', { lat: point.lat(), lng: point.lng(), time: checkTime.toLocaleString('de-DE') });
                  console.groupEnd();
                  console.groupEnd();
                  console.groupEnd();
                  return;
                }
                console.log(`Niederschlag bei ${checkTime.toLocaleTimeString('de-DE')}:`, {
                  Koordinaten: { lat: point.lat(), lng: point.lng() },
                  Niederschlag: precip.toFixed(1) + ' mm/h',
                  Akzeptiert: precip <= limit ? 'Ja' : 'Nein (Regen)'
                });
                if (precip > limit) {
                  nextRainTime = checkTime;
                  break;
                }
              }
              console.groupEnd();
              break;
            }
            console.groupEnd();
          }
          console.groupEnd();

          if (firstDryTime) {
            const timeStr = firstDryTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' });
            const rainTimeStr = nextRainTime ? nextRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' }) : 'kein Regen erwartet';
            showResult(`ðŸŒ§ Regen auf der Strecke um ${firstRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} â€” trockenes Zeitfenster ab ${timeStr}, ${rainTimeStr}`, 'muted');
            console.log('Ergebnis:', {
              Erster_Regen: firstRainTime.toLocaleString('de-DE'),
              Trockenes_Zeitfenster: firstDryTime.toLocaleString('de-DE'),
              NÃ¤chstes_Regenfenster: rainTimeStr,
              Nachricht: `Regen um ${firstRainTime.toLocaleTimeString('de-DE', { hour: '2-digit', minute: '2-digit' })} â€” trockenes Zeitfenster ab ${timeStr}, ${rainTimeStr}`
            });
          } else {
            showResult(`ðŸŒ§ Kein trockenes Zeitfenster innerhalb der nÃ¤chsten ${(searchWindow / 3600)} Stunden`, 'muted');
            console.log('Ergebnis:', `Kein trockenes Zeitfenster innerhalb der nÃ¤chsten ${(searchWindow / 3600)} Stunden`);
          }
          console.groupEnd();
        });
      });
    });
  }

  // Init
  renderRides();
  </script>
</body>
</html>
